package zpack

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"unicode/utf8"
)

// Pack data to a Go file.
//
// The data is a map where the key is the filename to store the packed data, and
// the contents a variable -> contents mapping.
//
// Example:
//
//     err := zpack.Pack(map[string]map[string]string{
//         "./db/pack.go": map[string]string{
//             "Schema": "./db/schema.sql",
//         },
//         "./handlers/pack.go": map[string]string{
//             "packPublic": "./public",
//             "packTpl":    "./tpl",
//         },
//     })
//     if err != nil {
//         fmt.Fprintln(os.Stderr, err)
//         os.Exit(1)
//     }
func Pack(data map[string]map[string]string, ignore ...string) error {
	for out, content := range data {
		fp, err := os.Create(out)
		if err != nil {
			return err
		}
		defer func() { fp.Close() }()

		err = Header(fp, filepath.Dir(out))
		if err != nil {
			return err
		}

		var varnames []string
		for v := range content {
			varnames = append(varnames, v)
		}
		sort.Strings(varnames)

		for _, varname := range varnames {
			files := content[varname]
			st, err := os.Stat(files)
			if err != nil {
				return err
			}

			if st.IsDir() {
				err = Dir(fp, varname, files, ignore...)
			} else {
				err = File(fp, varname, files)
			}
		}

		err = fp.Close()
		if err != nil {
			return err
		}
		err = Format(out)
		if err != nil {
			return err
		}
	}

	return nil
}

// Header writes a file header, which is a code generation comment and package
// declaration.
func Header(fp io.Writer, pkg string) error {
	_, err := fp.Write([]byte("// Code generated by pack.go; DO NOT EDIT.\n\n"))
	if err != nil {
		return err
	}
	_, err = fp.Write([]byte("package " + pkg + "\n\nimport \"encoding/base64\"\n\n"))
	return err
}

// File writes a single file as a variable.
func File(fp io.Writer, varname, path string) error {
	d, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(fp, "var %s = %s\n", varname, enc(d))
	return err
}

// Dir recursively writes all files in a directory as variables.
func Dir(fp io.Writer, varname, dir string, ignore ...string) error {
	_, err := fp.Write([]byte("var " + varname + " = map[string][]byte{\n"))
	if err != nil {
		return err
	}

	err = filepath.Walk(dir, func(path string, st os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if st.IsDir() {
			return nil
		}
		for _, ig := range ignore {
			// Special case to exclude VCS "keep" files.
			if strings.HasSuffix(path, ig) {
				return nil
			}
		}

		d, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}

		_, err = fmt.Fprintf(fp, "\t\"%s\": %s,\n", path, enc(d))
		return err
	})
	if err != nil {
		return err
	}

	_, err = fp.Write([]byte("}\n\n"))
	return err
}

// Format the given file with gofmt.
func Format(path string) error {
	out, err := exec.Command("gofmt", "-w", path).CombinedOutput()
	if err != nil {
		return fmt.Errorf("gofmt: %s: %s", err, string(out))
	}
	return nil
}

func enc(s []byte) string {
	if bytes.IndexByte(s, 0) == -1 && utf8.Valid(s) {
		return fmt.Sprintf("[]byte(`%s`)", bytes.Replace(s, []byte("`"), []byte("` + \"`\" + `"), -1))
	}

	// TODO: maybe wrap?
	return fmt.Sprintf(`func() []byte {
		s, err := base64.StdEncoding.DecodeString("%s")
		if err != nil {
			panic(err)
		}
		return s
	}()`, base64.StdEncoding.EncodeToString(s))
}
